<!DOCTYPE HTML><html><head><title>RSS Team 13</title><link rel="stylesheet" type="text/css" href="../../css/style.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']],displayMath: [['$$','$$']],skipTags: ["script","noscript","style","textarea","code"]},TeX: {equationNumbers: {autoNumber: "AMS"}}});</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script></head><body><div id="main"><div id="logo"><div id="logo_text"><h1><a href="../.."><span class="logo_colour">RSS Team 13</span></a></h1><h2>MIT Spring 2019</h2></div></div><div id="header"><div id="menubar"><ul id="menu"><li class=""><a href="../..">Home</a></li><li class="selected"><a href="../../labs">Labs</a></li><li><a href="https://www.youtube.com/watch?v=dQw4w9WgXcQ">Video</a></li><li><a href="https://github.mit.edu/rss2019-13">Github</a></li></ul></div></div><div id="site_content"><div id="content"><h1>Lab 3</h1>
For Lab 3, our goal was to give our robot wall-following abilities as well as a safety controller that prevented collisions. In order to do this, we created a hierarchy of programs that would allow the robot to efficiently follow walls without causing harm to itself or its surroundings.
<h2>Table of Contents</h2>
<ol>
<li>Wall Follower</li>
</ol>
<ol>
<li>Safety Controller</li>
</ol>
<h1>Wall Follower</h1>
<h2>Scan Parser</h2>
Our robot uses a LIDAR 2D laser scanner to detect objects in its path. We used this scan data to determine where the walls were with respect to the robot. To do this, we
We then converted the laserscan data from polar coordinates to cartesian coordinates.
<h2>Wall Detector</h2>
<h2>Wall Follower Controller</h2>
Our wall follower consists of a PD controller that allows the robot to follow a wall to its left or right while maintaining a desired distance from the wall. After detecting a wall, the  program computes the distance and angle that the robot is positioned relative to the wall. It then determines the error in distance and angle from the desired state, and multiplies each error by some gain constant and publishes the sum to the
<h1>Safety Controller</h1>
<h2>Scan Parser</h2>
<h2>Object Detection</h2>
<h2>Collision Prevention Controller</h2>
</div></div></div></body></html>